#!/usr/bin/env bash
# bin/update-readme - Regenerate README sections from Formula/*.rb metadata
# Author: Christopher Boone
# Date: 2026-02-21

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
REPO_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly REPO_DIR
readonly README="${REPO_DIR}/README.md"
readonly FORMULA_DIR="${REPO_DIR}/Formula"

# Formula data arrays (parallel arrays, indexed by position)
NAMES=()
DESCS=()
HOMEPAGES=()
TYPES=()

# Grouped formula names by type
PREBUILT_NAMES=()
GORELEASER_NAMES=()
HEAD_NAMES=()

# Parse a single formula file and append to data arrays.
# Arguments:
#   $1 - Path to formula .rb file
function parse_formula() {
  local formula_path="${1}"
  local name
  name="${formula_path##*/}"
  name="${name%.rb}"

  local desc=""
  local homepage=""
  local formula_type="prebuilt"

  local line
  while IFS= read -r line; do
    if [[ -z "${desc}" ]] && [[ "${line}" =~ ^[[:space:]]*desc\ \"(.+)\" ]]; then
      desc="${BASH_REMATCH[1]}"
    fi
    if [[ -z "${homepage}" ]] && [[ "${line}" =~ ^[[:space:]]*homepage\ \"(.+)\" ]]; then
      homepage="${BASH_REMATCH[1]}"
    fi
    if [[ "${line}" =~ ^[[:space:]]*head\ \" ]]; then
      formula_type="head"
    fi
    if [[ "${line}" == *"# This file was generated by GoReleaser"* ]]; then
      formula_type="goreleaser"
    fi
  done < "${formula_path}"

  if [[ -z "${desc}" ]]; then
    echo "warning: ${name}: missing desc, using fallback" >&2
    desc="(no description)"
  fi
  if [[ -z "${homepage}" ]]; then
    echo "warning: ${name}: missing homepage, using fallback" >&2
    homepage="https://github.com/cboone/${name}"
  fi

  NAMES+=("${name}")
  DESCS+=("${desc}")
  HOMEPAGES+=("${homepage}")
  TYPES+=("${formula_type}")

  case "${formula_type}" in
    prebuilt) PREBUILT_NAMES+=("${name}") ;;
    goreleaser) GORELEASER_NAMES+=("${name}") ;;
    head) HEAD_NAMES+=("${name}") ;;
  esac
}

# Join formula names into natural language.
# Arguments:
#   $@ - Formula names
# Outputs:
#   Formatted name list to stdout (e.g., "`a`, `b`, and `c`")
function join_names() {
  local names=("${@}")
  local -i count=${#names[@]}

  # Backticks are literal Markdown, not command substitution.
  # shellcheck disable=SC2016
  if ((count == 1)); then
    printf '`%s`' "${names[0]}"
  elif ((count == 2)); then
    printf '`%s` and `%s`' "${names[0]}" "${names[1]}"
  else
    local -i i
    for ((i = 0; i < count - 1; i++)); do
      printf '`%s`, ' "${names[i]}"
    done
    printf 'and `%s`' "${names[count - 1]}"
  fi
}

# Generate the formulae Markdown table.
# Outputs:
#   Table rows to stdout
function generate_table() {
  local -i count=${#NAMES[@]}

  if ((count == 0)); then
    return
  fi

  # Calculate column widths for aligned pipes
  local -i formula_width=7  # "Formula"
  local -i desc_width=11    # "Description"

  local -i i
  for ((i = 0; i < count; i++)); do
    local cell
    cell="[\`${NAMES[i]}\`](${HOMEPAGES[i]})"
    local -i cell_len=${#cell}
    if ((cell_len > formula_width)); then
      formula_width=${cell_len}
    fi
    local -i desc_len=${#DESCS[i]}
    if ((desc_len > desc_width)); then
      desc_width=${desc_len}
    fi
  done

  # Header row
  printf '| %-*s | %-*s |\n' "${formula_width}" "Formula" "${desc_width}" "Description"
  # Separator row
  local formula_dashes
  formula_dashes="$(printf '%*s' "${formula_width}" '' | tr ' ' '-')"
  local desc_dashes
  desc_dashes="$(printf '%*s' "${desc_width}" '' | tr ' ' '-')"
  printf '| %s | %s |\n' "${formula_dashes}" "${desc_dashes}"
  # Data rows
  for ((i = 0; i < count; i++)); do
    local cell
    cell="[\`${NAMES[i]}\`](${HOMEPAGES[i]})"
    printf '| %-*s | %-*s |\n' "${formula_width}" "${cell}" "${desc_width}" "${DESCS[i]}"
  done
}

# Generate the install commands code block.
# Outputs:
#   Fenced code block to stdout
function generate_install() {
  local -i count=${#NAMES[@]}

  if ((count == 0)); then
    return
  fi

  echo '```bash'
  local -i i
  for ((i = 0; i < count; i++)); do
    echo "brew install cboone/tap/${NAMES[i]}"
  done
  echo '```'
}

# Generate a single note bullet for a formula type group.
# Arguments:
#   $1 - Formula type (prebuilt, goreleaser, head)
#   $@ - (shift) Formula names in the group
# Outputs:
#   Bullet point to stdout
function generate_note_bullet() {
  local formula_type="${1}"
  shift
  local names=("${@}")
  local -i count=${#names[@]}

  local joined
  joined="$(join_names "${names[@]}")"

  case "${formula_type}" in
    prebuilt)
      if ((count == 1)); then
        echo "- ${joined} installs a pre-built binary from the latest release."
      else
        echo "- ${joined} install pre-built binaries from the latest releases."
      fi
      ;;
    goreleaser)
      if ((count == 1)); then
        echo "- ${joined} installs a pre-built binary from a GoReleaser-managed release."
      else
        echo "- ${joined} install pre-built binaries from GoReleaser-managed releases."
      fi
      ;;
    head)
      if ((count == 1)); then
        echo "- ${joined} is a HEAD-only formula that builds from source."
      else
        echo "- ${joined} are HEAD-only formulae that build from source."
      fi
      ;;
  esac
}

# Generate the notes section.
# Outputs:
#   Bullet list to stdout
function generate_notes() {
  if ((${#PREBUILT_NAMES[@]} > 0)); then
    generate_note_bullet "prebuilt" "${PREBUILT_NAMES[@]}"
  fi
  if ((${#GORELEASER_NAMES[@]} > 0)); then
    generate_note_bullet "goreleaser" "${GORELEASER_NAMES[@]}"
  fi
  if ((${#HEAD_NAMES[@]} > 0)); then
    generate_note_bullet "head" "${HEAD_NAMES[@]}"
  fi
}

# Check if a marker pair exists in the README.
# Arguments:
#   $1 - Section name (e.g., "formulae-table")
# Returns:
#   0 if both markers found, 1 otherwise
function has_markers() {
  local section="${1}"

  if ! grep -q "<!-- BEGIN:${section} -->" "${README}"; then
    echo "warning: missing <!-- BEGIN:${section} --> marker in README" >&2
    return 1
  fi
  if ! grep -q "<!-- END:${section} -->" "${README}"; then
    echo "warning: missing <!-- END:${section} --> marker in README" >&2
    return 1
  fi
  return 0
}

# Replace content between marker pairs in the README.
# Arguments:
#   $1 - Path to output file
function replace_sections() {
  local output="${1}"

  local table_content
  table_content="$(generate_table)"

  local install_content
  install_content="$(generate_install)"

  local notes_content
  notes_content="$(generate_notes)"

  # Check for missing markers
  has_markers "formulae-table" || true
  has_markers "install-commands" || true
  has_markers "notes" || true

  # Single awk pass replaces content between all three marker pairs.
  # Uses ENVIRON to avoid awk -v escape sequence interpretation.
  TABLE="${table_content}" \
  INSTALL="${install_content}" \
  NOTES="${notes_content}" \
  awk '
    BEGIN {
      table = ENVIRON["TABLE"]
      install = ENVIRON["INSTALL"]
      notes = ENVIRON["NOTES"]
    }
    /<!-- BEGIN:formulae-table -->/  { print; if (table != "")   { print ""; print table; print "" };   skip = 1; next }
    /<!-- END:formulae-table -->/    { skip = 0; print; next }
    /<!-- BEGIN:install-commands -->/ { print; if (install != "") { print ""; print install; print "" }; skip = 1; next }
    /<!-- END:install-commands -->/   { skip = 0; print; next }
    /<!-- BEGIN:notes -->/           { print; if (notes != "")   { print ""; print notes; print "" };   skip = 1; next }
    /<!-- END:notes -->/             { skip = 0; print; next }
    !skip { print }
  ' "${README}" > "${output}"
}

function main() {
  local -i check_mode=0

  if [[ "${1:-}" == "--check" ]]; then
    check_mode=1
  fi

  # Collect formula files, sorted alphabetically
  local formula_files=()
  shopt -s nullglob
  for f in "${FORMULA_DIR}"/*.rb; do
    formula_files+=("${f}")
  done
  shopt -u nullglob

  if ((${#formula_files[@]} == 0)); then
    echo "warning: no formula files found in ${FORMULA_DIR}" >&2
  fi

  # Parse all formulas
  local f
  for f in "${formula_files[@]}"; do
    parse_formula "${f}"
  done

  local tmp
  tmp="$(mktemp)"
  # Expand path now so the trap works after main() returns.
  # shellcheck disable=SC2064
  trap "rm -f '${tmp}'" EXIT

  replace_sections "${tmp}"

  if ((check_mode)); then
    if ! diff -q "${README}" "${tmp}" > /dev/null 2>&1; then
      echo "README.md is out of date. Run 'bin/update-readme' to update." >&2
      diff -u "${README}" "${tmp}" >&2 || true
      exit 1
    fi
    echo "README.md is up to date." >&2
  else
    cp "${tmp}" "${README}"
    echo "README.md updated." >&2
  fi
}

main "${@}"
